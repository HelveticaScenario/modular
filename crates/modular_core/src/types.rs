//! Types and traits for the modular synthesizer DSP system.
//!
//! # Safety Model for Module UnsafeCell Access
//!
//! Module wrapper structs (generated by `#[derive(Module)]`) use `UnsafeCell` for interior
//! mutability instead of `Mutex`/`RwLock` for performance on the audio thread.
//!
//! ## Why This Is Safe
//!
//! 1. **Exclusive Audio Thread Ownership**: After construction, all modules live in
//!    `AudioProcessor::patch` which is owned exclusively by the audio thread closure.
//!    See `crates/modular/src/audio.rs` `make_stream()`.
//!
//! 2. **Command Queue Isolation**: The main thread communicates via `PatchUpdate`
//!    commands through an `rtrb` SPSC queue. It never directly accesses module state.
//!
//! 3. **No Escaping References**: Module `Arc`s are stored in `Patch::sampleables` and
//!    are never cloned or sent to other threads after being added to the patch.
//!
//! ## Invariants (DO NOT VIOLATE - will cause undefined behavior)
//!
//! - **NEVER** call `Sampleable` trait methods from the main thread
//! - **NEVER** clone module `Arc`s and send them across threads
//! - **NEVER** access `Patch::sampleables` from outside `AudioProcessor`
//! - **ALWAYS** use the command queue for mainâ†’audio communication
//!
//! ## Exception: AudioIn Module
//!
//! The `AudioIn` module is special - it uses `Arc<Mutex<PolyOutput>>` because its input
//! buffer is legitimately shared between the audio input callback and the audio processing
//! thread. This is the only module that requires a mutex.

use napi::Env;
use napi::Result;
use napi::bindgen_prelude::{FromNapiValue, Object, ToNapiValue};
use napi_derive::napi;
use regex::Regex;
use rust_music_theory::note::{Notes, Pitch};
use rust_music_theory::scale::Scale;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::borrow::Cow;
use std::fmt::Debug;
use std::ops::{Add, Deref, Div, Mul, Sub};
use std::result::Result as StdResult;
use std::{
    collections::HashMap,
    sync::{self, Arc},
};

use crate::dsp::utils::{hz_to_voct, midi_to_voct};
use crate::patch::Patch;
use crate::poly::PolyOutput;

// ============================================================================
// Well-known module IDs and ports
// ============================================================================

/// Well-known modules in the system (root, clock, etc.)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum WellKnownModule {
    /// The root output module
    RootOutput,
    /// The root clock module (provides playhead)
    RootClock,
    /// The signal exposed to the dsl
    RootInput,
    /// The instance of AudioIn thats connected to AudioIn but hidden from the user
    HiddenAudioIn,
}

impl WellKnownModule {
    /// Get the module ID string
    pub fn id(&self) -> &'static str {
        match self {
            WellKnownModule::RootOutput => "ROOT_OUTPUT",
            WellKnownModule::RootClock => "ROOT_CLOCK",
            WellKnownModule::RootInput => "ROOT_INPUT",
            // We also use this for the module type string
            WellKnownModule::HiddenAudioIn => "HIDDEN_AUDIO_IN",
        }
    }

    /// Get the default output port name for this module
    pub fn default_port(&self) -> &'static str {
        match self {
            WellKnownModule::RootOutput => "output",
            WellKnownModule::RootClock => "playhead",
            WellKnownModule::RootInput => "output",
            WellKnownModule::HiddenAudioIn => "input", // doesn't actually matter, only one port
        }
    }

    /// Create a Cable signal pointing to this module's default port at the given channel
    pub fn to_cable(&self, channel: usize, port: &str) -> Signal {
        Signal::Cable {
            module: self.id().into(),
            module_ptr: std::sync::Weak::new(),
            port: port.into(),
            channel,
        }
    }

    /// Create a PolySignal with cables to this module's default port for the given channels
    pub fn to_poly_signal(&self, channels: &[usize], port: &str) -> crate::poly::PolySignal {
        crate::poly::PolySignal::poly(
            &channels
                .iter()
                .map(|&ch| self.to_cable(ch, port))
                .collect::<Vec<_>>(),
        )
    }
}

lazy_static! {
    pub static ref ROOT_ID: String = WellKnownModule::RootOutput.id().into();
    pub static ref ROOT_OUTPUT_PORT: &'static str = WellKnownModule::RootOutput.default_port();
    pub static ref ROOT_CLOCK_ID: String = WellKnownModule::RootClock.id().into();
    static ref RE_HZ: Regex = Regex::new(r"^(-?\d*\.?\d+)hz$").unwrap();
    static ref RE_MIDI: Regex = Regex::new(r"^(-?\d*\.?\d+)m$").unwrap();
    static ref RE_SCALE: Regex = Regex::new(r"^(-?\d*\.?\d+)s\(([^:]+):([^)]+)\)$").unwrap();
    static ref RE_NOTE: Regex = Regex::new(r"^([A-Ga-g])([#b]?)(-?\d+)?$").unwrap();
}

pub trait MessageHandler {
    fn handled_message_tags(&self) -> &'static [MessageTag] {
        &[]
    }

    fn handle_message(&self, _message: &Message) -> Result<()> {
        Ok(())
    }
}

pub trait StatefulModule {
    fn get_state(&self) -> Option<serde_json::Value> {
        None
    }
}

/// Trait for modules that need to perform work after the patch is updated.
/// Modules that need custom behavior should implement this trait and use the
/// `#[patch_update]` attribute on their Module derive.
pub trait PatchUpdateHandler {
    /// Called after the patch is updated and all modules are connected.
    /// Override to refresh caches or perform other post-update work.
    fn on_patch_update(&mut self);
}

pub trait Sampleable: MessageHandler + Send + Sync {
    fn get_id(&self) -> &str;
    fn tick(&self) -> ();
    fn update(&self) -> ();
    /// Get polyphonic sample output for a port.
    fn get_poly_sample(&self, port: &str) -> Result<PolyOutput>;
    fn get_module_type(&self) -> &str;
    fn try_update_params(&self, params: serde_json::Value) -> Result<()>;
    fn connect(&self, patch: &Patch);
    /// Called after the patch is updated and all modules are connected.
    /// Modules can override this to refresh caches or perform other post-update work.
    fn on_patch_update(&self) {}
    fn get_state(&self) -> Option<serde_json::Value> {
        None
    }
}

pub trait Module {
    fn install_constructor(map: &mut HashMap<String, SampleableConstructor>);
    fn get_schema() -> ModuleSchema;

    /// Register this module's parameter validator in the provided map.
    ///
    /// The key is the module type string (e.g. "noise"). The value is a function
    /// that attempts to deserialize a JSON params object into the module's concrete
    /// `*Params` type.
    fn install_params_validator(map: &mut HashMap<String, ParamsValidator>);

    /// Validate a JSON params object by attempting to parse it as the module's concrete
    /// params type.
    ///
    /// This is intended for server-side patch validation before applying the patch.
    fn validate_params_json(params: &serde_json::Value) -> napi::Result<()>;

    /// Register this module's channel count deriver in the provided map.
    ///
    /// The key is the module type string (e.g. "mix"). The value is a function
    /// that derives the output channel count from a JSON params object.
    fn install_channel_count_deriver(map: &mut HashMap<String, ChannelCountDeriver>) {
        // Default implementation: register the standard derive_channel_count
        let schema = Self::get_schema();
        map.insert(schema.name, Self::derive_channel_count);
    }

    /// Derive the output channel count from a JSON params object.
    ///
    /// Returns the derived channel count, or None if it cannot be determined
    /// from the params alone. The default implementation handles:
    /// 1. Hardcoded channels (from schema)
    /// 2. channels_param value (from params JSON)
    /// 3. Max of PolySignal input array lengths (inferred from JSON arrays)
    fn derive_channel_count(params: &serde_json::Value) -> Option<usize>;
}

/// Function pointer type used to validate a module's `ModuleState.params`.
///
/// The validator should return Ok if deserialization into the module's concrete params type succeeds.
pub type ParamsValidator = fn(&serde_json::Value) -> napi::Result<()>;

/// Function pointer type used to derive a module's output channel count from its params.
///
/// Returns the derived channel count, or None if it cannot be determined.
pub type ChannelCountDeriver = fn(&serde_json::Value) -> Option<usize>;

/// Helper function to derive channel count from JSON params by finding max array length.
///
/// This is used by the default `derive_channel_count` implementation to infer channel count
/// from PolySignal inputs. PolySignal serializes as an array of Signals, so we look for
/// arrays and return the maximum length found.
pub fn derive_channel_count_from_json(params: &serde_json::Value) -> Option<usize> {
    use crate::poly::PORT_MAX_CHANNELS;

    fn max_array_len(value: &serde_json::Value) -> usize {
        match value {
            serde_json::Value::Array(arr) => {
                // Check if this looks like a PolySignal (array of signals)
                // A signal is either a number, string, or object with "type" field
                let is_poly_signal = arr.iter().all(|v| {
                    matches!(
                        v,
                        serde_json::Value::Number(_) | serde_json::Value::String(_)
                    ) || (v.is_object() && v.get("type").is_some())
                });

                if is_poly_signal && !arr.is_empty() {
                    // This array is a PolySignal - its length is the channel count
                    arr.len()
                } else {
                    // This might be an array of PolySignals (like Vec<PolySignal>)
                    // or nested structures - recurse into each element
                    arr.iter().map(max_array_len).max().unwrap_or(0)
                }
            }
            serde_json::Value::Object(obj) => {
                // Recurse into object values
                obj.values().map(max_array_len).max().unwrap_or(0)
            }
            _ => 0,
        }
    }

    let max_len = max_array_len(params);
    if max_len > 0 {
        Some(max_len.clamp(1, PORT_MAX_CHANNELS))
    } else {
        Some(1) // Default to 1 channel if no arrays found
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Config {
    pub module_type: String,
    pub params: Value,
}

pub type SampleableMap = HashMap<String, Arc<Box<dyn Sampleable>>>;

/// One-pole lowpass filter for parameter smoothing to prevent clicking
/// Coefficient of 0.99 gives roughly 5ms smoothing time at 48kHz
const SMOOTHING_COEFF: f32 = 0.99;

pub fn smooth_value(current: f32, target: f32) -> f32 {
    current * SMOOTHING_COEFF + target * (1.0 - SMOOTHING_COEFF)
}

#[derive(Debug, Default, Clone, Copy)]
pub struct Clickless {
    value: f32,
    initialized: bool,
}
impl Clickless {
    pub fn update(&mut self, input: f32) {
        if !self.initialized {
            self.value = input;
            self.initialized = true;
            return;
        }
        self.value = smooth_value(self.value, input);
    }
}

impl From<Clickless> for f32 {
    fn from(clickless: Clickless) -> Self {
        clickless.value
    }
}

impl From<f32> for Clickless {
    fn from(value: f32) -> Self {
        Clickless { value, initialized: false }
    }
}

impl Deref for Clickless {
    type Target = f32;

    fn deref(&self) -> &Self::Target {
        &self.value
    }
}

impl Add<f32> for Clickless {
    type Output = f32;
    fn add(self, rhs: f32) -> Self::Output {
        self.value + rhs
    }
}

impl Add for Clickless {
    type Output = f32;
    fn add(self, rhs: Self) -> Self::Output {
        self.value + rhs.value
    }
}

impl Sub<f32> for Clickless {
    type Output = f32;
    fn sub(self, rhs: f32) -> Self::Output {
        self.value - rhs
    }
}

impl Sub for Clickless {
    type Output = f32;
    fn sub(self, rhs: Self) -> Self::Output {
        self.value - rhs.value
    }
}

impl Mul<f32> for Clickless {
    type Output = f32;
    fn mul(self, rhs: f32) -> Self::Output {
        self.value * rhs
    }
}

impl Mul for Clickless {
    type Output = f32;
    fn mul(self, rhs: Self) -> Self::Output {
        self.value * rhs.value
    }
}

impl Div<f32> for Clickless {
    type Output = f32;
    fn div(self, rhs: f32) -> Self::Output {
        self.value / rhs
    }
}

impl Div for Clickless {
    type Output = f32;
    fn div(self, rhs: Self) -> Self::Output {
        self.value / rhs.value
    }
}

pub trait Connect {
    fn connect(&mut self, patch: &Patch);
}

// ============================================================================
// No-op Connect impls for primitive types
// ============================================================================

macro_rules! impl_connect_noop {
    ($($t:ty),*) => {
        $(impl Connect for $t {
            fn connect(&mut self, _patch: &Patch) {}
        })*
    };
}

impl_connect_noop!(
    f32, f64, i8, i16, i32, i64, u8, u16, u32, u64, usize, isize, bool, String
);

// ============================================================================
// Recursive Connect impls for container types
// ============================================================================

impl<T: Connect> Connect for Vec<T> {
    fn connect(&mut self, patch: &Patch) {
        for item in self {
            item.connect(patch);
        }
    }
}

impl<T: Connect> Connect for Option<T> {
    fn connect(&mut self, patch: &Patch) {
        if let Some(inner) = self {
            inner.connect(patch);
        }
    }
}

impl<T: Connect> Connect for Box<T> {
    fn connect(&mut self, patch: &Patch) {
        (**self).connect(patch);
    }
}

impl<T: Connect, const N: usize> Connect for [T; N] {
    fn connect(&mut self, patch: &Patch) {
        for item in self {
            item.connect(patch);
        }
    }
}

impl<V: Connect> Connect for std::collections::HashMap<String, V> {
    fn connect(&mut self, patch: &Patch) {
        for v in self.values_mut() {
            v.connect(patch);
        }
    }
}

impl<V: Connect> Connect for std::collections::BTreeMap<String, V> {
    fn connect(&mut self, patch: &Patch) {
        for v in self.values_mut() {
            v.connect(patch);
        }
    }
}

// Tuples (arity 1-5)
impl<T1: Connect> Connect for (T1,) {
    fn connect(&mut self, patch: &Patch) {
        self.0.connect(patch);
    }
}

impl<T1: Connect, T2: Connect> Connect for (T1, T2) {
    fn connect(&mut self, patch: &Patch) {
        self.0.connect(patch);
        self.1.connect(patch);
    }
}

impl<T1: Connect, T2: Connect, T3: Connect> Connect for (T1, T2, T3) {
    fn connect(&mut self, patch: &Patch) {
        self.0.connect(patch);
        self.1.connect(patch);
        self.2.connect(patch);
    }
}

impl<T1: Connect, T2: Connect, T3: Connect, T4: Connect> Connect for (T1, T2, T3, T4) {
    fn connect(&mut self, patch: &Patch) {
        self.0.connect(patch);
        self.1.connect(patch);
        self.2.connect(patch);
        self.3.connect(patch);
    }
}

impl<T1: Connect, T2: Connect, T3: Connect, T4: Connect, T5: Connect> Connect
    for (T1, T2, T3, T4, T5)
{
    fn connect(&mut self, patch: &Patch) {
        self.0.connect(patch);
        self.1.connect(patch);
        self.2.connect(patch);
        self.3.connect(patch);
        self.4.connect(patch);
    }
}

/// Trait for params structs to provide references to all their top-level PolySignal fields.
/// This is auto-derived by the Connect macro for params structs.
/// For params structs that manually implement Connect, this trait should also be manually implemented.
pub trait PolySignalFields {
    /// Collect references to all top-level PolySignal fields for channel count calculation.
    fn poly_signal_fields(&self) -> Vec<&crate::poly::PolySignal> {
        // Default implementation returns empty vec (for mono-only modules)
        vec![]
    }
}

struct ParsedNote {
    pitch: Pitch,
    octave: i32,
}

fn parse_note_str(s: &str) -> StdResult<ParsedNote, String> {
    let caps = RE_NOTE
        .captures(s)
        .ok_or("Invalid note format".to_string())?;
    let name = &caps[1];
    let acc = &caps[2];
    let octave: i32 = caps
        .get(3)
        .map(|m| m.as_str().parse().unwrap_or(3))
        .unwrap_or(3);

    let pitch_str = format!("{}{}", name, acc);
    let pitch = Pitch::from_str(&pitch_str).ok_or("Invalid pitch".to_string())?;
    Ok(ParsedNote { pitch, octave })
}

fn parse_signal_string(s: &str) -> StdResult<f32, String> {
    if let Some(caps) = RE_HZ.captures(s) {
        let hz: f32 = caps[1]
            .parse()
            .map_err(|_| "Invalid frequency number".to_string())?;
        if hz <= 0.0 {
            return Err("Frequency must be positive".to_string());
        }
        let volts = hz_to_voct(hz);
        return Ok(volts);
    }

    if let Some(caps) = RE_MIDI.captures(s) {
        let midi: f32 = caps[1]
            .parse()
            .map_err(|_| "Invalid MIDI number".to_string())?;
        let volts = midi_to_voct(midi);
        return Ok(volts);
    }

    if let Some(caps) = RE_SCALE.captures(s) {
        let val: f32 = caps[1]
            .parse()
            .map_err(|_| "Invalid scale interval number".to_string())?;
        let root_str = &caps[2];
        let scale_str = &caps[3];

        let root_note = parse_note_str(root_str)?;
        let scale_def = format!("{} {}", root_note.pitch, scale_str);
        let scale =
            Scale::from_regex(&scale_def).map_err(|_| "Invalid scale definition".to_string())?;

        let interval_idx = val.floor() as i64;
        let cents = (val - interval_idx as f32) * 100.0;

        let notes = scale.notes();
        let note_len = notes.len();
        if note_len == 0 {
            return Err("Scale has no notes".to_string());
        }

        let effective_len = if note_len > 1 && notes[0].pitch == notes[note_len - 1].pitch {
            note_len - 1
        } else {
            note_len
        };
        let len = effective_len as i64;

        let scale_root_octave = notes[0].octave as i32;

        let (octave_shift, note_idx) = if interval_idx >= 0 {
            ((interval_idx / len), (interval_idx % len) as usize)
        } else {
            let abs_idx = -interval_idx - 1;
            let octave_down = (abs_idx / len) + 1;
            let note_from_end = (abs_idx % len) as usize;
            (-octave_down, len as usize - 1 - note_from_end)
        };

        let base_note = &notes[note_idx];
        let relative_octave = (base_note.octave as i32) - scale_root_octave;
        let target_octave = (root_note.octave as i32) + relative_octave + (octave_shift as i32);

        let pc_val = base_note.pitch.into_u8();

        // Standard MIDI: (octave + 1) * 12 + pitch_class, where C4 = MIDI 60
        let midi = (target_octave as f32 + 1.0) * 12.0 + (pc_val as f32);
        let midi_with_cents = midi + (cents / 100.0);

        let volts = midi_to_voct(midi_with_cents);
        return Ok(volts);
    }

    if let Ok(note) = parse_note_str(s) {
        let pc_val = note.pitch.into_u8();
        // Standard MIDI: (octave + 1) * 12 + pitch_class, where C4 = MIDI 60
        let midi = (note.octave as f32 + 1.0) * 12.0 + (pc_val as f32);
        let volts = midi_to_voct(midi);
        return Ok(volts);
    }

    Err("Invalid signal format".to_string())
}

/// A single-channel signal value.
///
/// This represents either a constant voltage, a cable connection to a specific
/// channel of another module's output, or a disconnected input.
#[derive(Clone, Debug, Default)]
pub enum Signal {
    /// Static voltage value (mono)
    Volts(f32),
    /// Cable connection to another module's output at a specific channel
    Cable {
        module: String,
        module_ptr: std::sync::Weak<Box<dyn Sampleable>>,
        port: String,
        /// Which channel of the output to read (0-indexed)
        channel: usize,
    },
    #[default]
    Disconnected,
}

// Custom serde deserialization to allow a bare number as shorthand for volts.
//
// Examples accepted:
// - 0.5                      -> Signal::Volts(0.5)
// - "440hz"                  -> Signal::Volts(computed voltage)
// - { type: 'cable', module, port, channel } -> Signal::Cable
//
// Note: Arrays are no longer accepted for Signal - use PolySignal for polyphonic inputs.
impl<'de> Deserialize<'de> for Signal {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum SignalDe {
            Number(f64),
            String(String),
            Tagged(SignalTagged),
        }

        #[derive(Deserialize)]
        #[serde(
            tag = "type",
            rename_all = "camelCase",
            rename_all_fields = "camelCase"
        )]
        enum SignalTagged {
            Cable {
                module: String,
                port: String,
                #[serde(default)]
                channel: usize,
            },
            Disconnected,
        }

        match SignalDe::deserialize(deserializer)? {
            SignalDe::Number(value) => Ok(Signal::Volts(value as f32)),
            SignalDe::String(s) => parse_signal_string(&s)
                .map(Signal::Volts)
                .map_err(serde::de::Error::custom),
            SignalDe::Tagged(tagged) => Ok(match tagged {
                SignalTagged::Cable {
                    module,
                    port,
                    channel,
                } => Signal::Cable {
                    module,
                    module_ptr: sync::Weak::new(),
                    port,
                    channel,
                },
                SignalTagged::Disconnected => Signal::Disconnected,
            }),
        }
    }
}

impl serde::Serialize for Signal {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeMap;
        match self {
            Signal::Volts(v) => serializer.serialize_f32(*v),
            Signal::Cable {
                module,
                port,
                channel,
                ..
            } => {
                let mut map = serializer.serialize_map(Some(4))?;
                map.serialize_entry("type", "cable")?;
                map.serialize_entry("module", module)?;
                map.serialize_entry("port", port)?;
                map.serialize_entry("channel", channel)?;
                map.end()
            }
            Signal::Disconnected => {
                let mut map = serializer.serialize_map(Some(1))?;
                map.serialize_entry("type", "disconnected")?;
                map.end()
            }
        }
    }
}

#[derive(JsonSchema)]
#[serde(untagged)]
#[allow(dead_code)]
enum SignalSchema {
    Number(f64),
    String(String),
    Tagged(SignalTaggedSchema),
}

#[derive(JsonSchema)]
#[serde(
    tag = "type",
    rename_all = "camelCase",
    rename_all_fields = "camelCase"
)]
#[allow(dead_code)]
enum SignalTaggedSchema {
    Cable {
        module: String,
        port: String,
        #[serde(default)]
        channel: usize,
    },
    Disconnected,
}

impl JsonSchema for Signal {
    fn schema_name() -> Cow<'static, str> {
        Cow::Borrowed("Signal")
    }

    fn json_schema(r#gen: &mut schemars::SchemaGenerator) -> schemars::Schema {
        SignalSchema::json_schema(r#gen)
    }
}

impl Signal {
    /// Get the mono voltage value from this signal.
    /// For Volts, returns the stored value.
    /// For Cable, fetches the specific channel from the connected module's output.
    /// For Disconnected, returns 0.0.
    pub fn get_value(&self) -> f32 {
        match self {
            Signal::Volts(v) => *v,
            Signal::Cable {
                module_ptr,
                port,
                channel,
                ..
            } => match module_ptr.upgrade() {
                Some(module_ptr) => module_ptr
                    .get_poly_sample(port)
                    .map(|p| p.get_cycling(*channel))
                    .unwrap_or(0.0),
                None => 0.0,
            },
            Signal::Disconnected => 0.0,
        }
    }

    /// Get value with fallback for disconnected inputs (normalled input)
    pub fn get_value_or(&self, default: f32) -> f32 {
        if self.is_disconnected() {
            default
        } else {
            self.get_value()
        }
    }

    /// Check if the signal is disconnected
    pub fn is_disconnected(&self) -> bool {
        matches!(self, Signal::Disconnected)
    }
}

impl Connect for Signal {
    fn connect(&mut self, patch: &Patch) {
        if let Signal::Cable {
                module, module_ptr, ..
            } = self
            && let Some(sampleable) = patch.sampleables.get(module) {
                *module_ptr = Arc::downgrade(sampleable);
            }
    }
}

impl PartialEq for Box<dyn Sampleable> {
    fn eq(&self, other: &Self) -> bool {
        self.get_id() == other.get_id()
    }
}

impl PartialEq for Signal {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Signal::Volts(v1), Signal::Volts(v2)) => v1 == v2,
            (
                Signal::Cable {
                    module: module_1,
                    module_ptr: module_ptr_1,
                    port: port_1,
                    channel: channel_1,
                },
                Signal::Cable {
                    module: module_2,
                    module_ptr: module_ptr_2,
                    port: port_2,
                    channel: channel_2,
                },
            ) => {
                module_ptr_1.upgrade() == module_ptr_2.upgrade()
                    && port_1 == port_2
                    && module_1 == module_2
                    && channel_1 == channel_2
            }
            (Signal::Disconnected, Signal::Disconnected) => true,
            _ => false,
        }
    }
}

#[derive(
    Debug,
    Default,
    Clone,
    Copy,
    PartialOrd,
    PartialEq,
    Ord,
    Eq,
    Hash,
    Serialize,
    Deserialize,
    JsonSchema,
)]
#[serde(rename_all = "camelCase")]
pub enum InterpolationType {
    #[default]
    Linear,
    Step,
    SineIn,
    SineOut,
    SineInOut,
    QuadIn,
    QuadOut,
    QuadInOut,
    CubicIn,
    CubicOut,
    CubicInOut,
    QuartIn,
    QuartOut,
    QuartInOut,
    QuintIn,
    QuintOut,
    QuintInOut,
    ExpoIn,
    ExpoOut,
    ExpoInOut,
    CircIn,
    CircOut,
    CircInOut,
    BounceIn,
    BounceOut,
    BounceInOut,
}

impl Connect for InterpolationType {
    fn connect(&mut self, _patch: &Patch) {}
}

pub enum Seq {
    Fast,
    Slow,
}

#[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SignalParamSchema {
    pub name: String,
    pub description: String,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[napi(object)]
pub struct OutputSchema {
    pub name: String,
    pub description: String,
    /// Whether this output is polyphonic (PolyOutput) or monophonic (f32/f64)
    #[serde(default, skip_serializing_if = "std::ops::Not::not")]
    pub polyphonic: bool,
    /// Whether this is the default output for the module
    #[serde(default, skip_serializing_if = "std::ops::Not::not")]
    pub default: bool,
    /// The minimum value of the raw output range (before any remapping)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub min_value: Option<f64>,
    /// The maximum value of the raw output range (before any remapping)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_value: Option<f64>,
}

pub trait OutputStruct: Default + Send + Sync + 'static {
    fn copy_from(&mut self, other: &Self);
    /// Get polyphonic sample output for a port.
    fn get_poly_sample(&self, port: &str) -> Option<PolyOutput>;
    fn schemas() -> Vec<OutputSchema>
    where
        Self: Sized;
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SchemaContainer {
    pub schema: schemars::Schema,
}

impl ToNapiValue for SchemaContainer {
    unsafe fn to_napi_value(
        env: napi::sys::napi_env,
        val: Self,
    ) -> napi::Result<napi::sys::napi_value> {
        unsafe {
            ToNapiValue::to_napi_value(
                env,
                serde_json::to_value(val.schema).map_err(|e| {
                    napi::Error::from_reason(format!("Failed to serialize schema: {}", e))
                })?,
            )
        }
    }
}

impl FromNapiValue for SchemaContainer {
    unsafe fn from_napi_value(
        env: napi::sys::napi_env,
        napi_val: napi::sys::napi_value,
    ) -> napi::Result<Self> {
        unsafe {
            FromNapiValue::from_napi_value(env, napi_val).and_then(|js_value: Object| {
                Ok(SchemaContainer {
                    schema: Env::from_raw(env).from_js_value(js_value).map_err(|e| {
                        napi::Error::from_reason(format!("Failed to parse schema: {}", e))
                    })?,
                })
            })
        }
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[napi(object)]
pub struct PositionalArg {
    pub name: String,
    pub optional: bool,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[napi(object)]
pub struct ModuleSchema {
    pub name: String,
    pub description: String,
    #[napi(ts_type = "Record<string, unknown>")]
    pub params_schema: SchemaContainer,
    pub outputs: Vec<OutputSchema>,
    pub positional_args: Vec<PositionalArg>,
    /// If set, this module always produces exactly this many channels (no inference needed)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channels: Option<u8>,
    /// If set, the name of the parameter that controls channel count
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channels_param: Option<String>,
    /// If set, the default value for the channels param when not explicitly set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channels_param_default: Option<u8>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[napi(object)]
pub struct ModuleState {
    pub id: String,
    pub module_type: String,
    pub id_is_explicit: Option<bool>,
    // #[serde(default)]
    pub params: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(
    tag = "type",
    rename_all = "camelCase",
    rename_all_fields = "camelCase"
)]
#[napi]
pub enum ScopeItem {
    ModuleOutput {
        module_id: String,
        port_name: String,
    },
}

/// Statistics computed from scope buffer data
#[derive(Debug, Clone, Copy, Default)]
#[napi(object)]
pub struct ScopeStats {
    pub min: f64,
    pub max: f64,
    pub peak_to_peak: f64,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[napi(object)]
pub struct Scope {
    pub item: ScopeItem,
    pub ms_per_frame: u32,
    pub trigger_threshold: Option<i32>,
    /// Voltage scale for display (default 5.0). The scope displays from -scale to +scale.
    #[serde(default = "default_scope_scale")]
    pub scale: f64,
}

fn default_scope_scale() -> f64 {
    5.0
}

#[derive(Debug, Clone, PartialEq)]
// #[serde(rename_all = "camelCase")]
#[napi(object)]
pub struct PatchGraph {
    pub modules: Vec<ModuleState>,
    pub module_id_remaps: Option<Vec<ModuleIdRemap>>,
    // #[serde(default)]
    pub scopes: Vec<Scope>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[napi(object)]
pub struct ModuleIdRemap {
    pub from: String,
    pub to: String,
}

pub type SampleableConstructor = Box<dyn Fn(&String, f32) -> Result<Arc<Box<dyn Sampleable>>>>;

#[derive(Copy, Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum ClockMessages {
    Start,
    Stop,
}

/// MIDI note on message
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct MidiNoteOn {
    /// Source MIDI device name (None for legacy messages)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    pub channel: u8,
    pub note: u8,
    pub velocity: u8,
}

/// MIDI note off message
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct MidiNoteOff {
    /// Source MIDI device name (None for legacy messages)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    pub channel: u8,
    pub note: u8,
    pub velocity: u8,
}

/// MIDI control change message
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct MidiControlChange {
    /// Source MIDI device name (None for legacy messages)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    pub channel: u8,
    pub cc: u8,
    pub value: u8,
}

/// MIDI 14-bit control change message (CC 0-31 with LSB from CC 32-63)
/// Used for high-resolution continuous controllers.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct MidiControlChange14Bit {
    /// Source MIDI device name (None for legacy messages)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    pub channel: u8,
    /// CC number (0-31, the MSB controller number)
    pub cc: u8,
    /// 14-bit value (0-16383)
    pub value: u16,
}

/// MIDI pitch bend message
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct MidiPitchBend {
    /// Source MIDI device name (None for legacy messages)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    pub channel: u8,
    /// Pitch bend value: -8192 to 8191 (center = 0)
    pub value: i16,
}

/// MIDI channel pressure (aftertouch) message
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct MidiChannelPressure {
    /// Source MIDI device name (None for legacy messages)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    pub channel: u8,
    pub pressure: u8,
}

/// MIDI polyphonic key pressure message
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct MidiPolyPressure {
    /// Source MIDI device name (None for legacy messages)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    pub channel: u8,
    pub note: u8,
    pub pressure: u8,
}

#[derive(Clone, Debug, PartialEq, Eq, EnumTag, Serialize, Deserialize)]
#[serde(
    tag = "type",
    content = "data",
    rename_all = "camelCase",
    rename_all_fields = "camelCase"
)]
pub enum Message {
    Clock(ClockMessages),
    MidiNoteOn(MidiNoteOn),
    MidiNoteOff(MidiNoteOff),
    MidiCC(MidiControlChange),
    MidiCC14Bit(MidiControlChange14Bit),
    MidiPitchBend(MidiPitchBend),
    MidiChannelPressure(MidiChannelPressure),
    MidiPolyPressure(MidiPolyPressure),
    /// MIDI panic - all notes off
    MidiPanic,
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::from_str;

    #[test]
    fn test_signal_deserialization_volts() {
        let s: Signal = from_str("0.5").unwrap();
        match s {
            Signal::Volts(v) => assert_eq!(v, 0.5),
            _ => panic!("Expected Volts"),
        }
    }

    #[test]
    fn test_signal_deserialization_hz() {
        // C4 (~261.63Hz) is 0V
        let s: Signal = from_str("\"261.6255653005986hz\"").unwrap();
        match s {
            Signal::Volts(v) => assert!(v.abs() < 1e-5, "C4 should be 0V, got {}", v),
            _ => panic!("Expected Volts"),
        }

        // C5 (~523.25Hz) is 1V (one octave up)
        let s: Signal = from_str("\"523.2511306011972hz\"").unwrap();
        match s {
            Signal::Volts(v) => assert!((v - 1.0).abs() < 1e-5, "C5 should be 1V, got {}", v),
            _ => panic!("Expected Volts"),
        }
    }

    #[test]
    fn test_signal_deserialization_midi() {
        // MIDI 60 (C4) is 0V
        let s: Signal = from_str("\"60m\"").unwrap();
        match s {
            Signal::Volts(v) => assert!(v.abs() < 1e-6, "MIDI 60 should be 0V, got {}", v),
            _ => panic!("Expected Volts"),
        }

        // MIDI 72 (C5) is 1V
        let s: Signal = from_str("\"72m\"").unwrap();
        match s {
            Signal::Volts(v) => assert!((v - 1.0).abs() < 1e-6, "MIDI 72 should be 1V, got {}", v),
            _ => panic!("Expected Volts"),
        }
    }

    #[test]
    fn test_signal_deserialization_note() {
        // C4 (Middle C) is 0V
        let s: Signal = from_str("\"C4\"").unwrap();
        match s {
            Signal::Volts(v) => assert!(v.abs() < 1e-6, "C4 should be 0V, got {}", v),
            _ => panic!("Expected Volts"),
        }

        // C3 is -1V
        let s: Signal = from_str("\"C3\"").unwrap();
        match s {
            Signal::Volts(v) => assert!((v + 1.0).abs() < 1e-6, "C3 should be -1V, got {}", v),
            _ => panic!("Expected Volts"),
        }

        // C5 is 1V
        let s: Signal = from_str("\"C5\"").unwrap();
        match s {
            Signal::Volts(v) => assert!((v - 1.0).abs() < 1e-6, "C5 should be 1V, got {}", v),
            _ => panic!("Expected Volts"),
        }

        // A4 (440Hz) -> MIDI 69 -> (69-60)/12 = 0.75V
        let s: Signal = from_str("\"A4\"").unwrap();
        match s {
            Signal::Volts(v) => assert!((v - 0.75).abs() < 1e-6, "A4 should be 0.75V, got {}", v),
            _ => panic!("Expected Volts"),
        }

        // Sharps/Flats
        // C#4 -> MIDI 61 -> 1/12 V
        let s: Signal = from_str("\"C#4\"").unwrap();
        match s {
            Signal::Volts(v) => assert!(
                (v - (1.0 / 12.0)).abs() < 1e-6,
                "C#4 should be 1/12V, got {}",
                v
            ),
            _ => panic!("Expected Volts"),
        }
    }

    #[test]
    fn test_signal_deserialization_scale() {
        // 0s(C4:Major) -> treat as root -> C4 -> 0V
        let s: Signal = from_str("\"0s(C4:Major)\"").unwrap();
        match s {
            Signal::Volts(v) => assert!(v.abs() < 1e-6, "0s(C4:Major) should be 0V, got {}", v),
            _ => panic!("Expected Volts"),
        }

        // 1s(C4:Major) -> 2nd interval -> D4 -> 2 semitones -> 2/12 V
        let s: Signal = from_str("\"1s(C4:Major)\"").unwrap();
        match s {
            Signal::Volts(v) => assert!(
                (v - (2.0 / 12.0)).abs() < 1e-6,
                "1s(C4:Major) should be 2/12V, got {}",
                v
            ),
            _ => panic!("Expected Volts"),
        }

        // 2s(C4:Major) -> 3rd interval -> E4 -> 4 semitones -> 4/12 V
        let s: Signal = from_str("\"2s(C4:Major)\"").unwrap();
        match s {
            Signal::Volts(v) => assert!(
                (v - (4.0 / 12.0)).abs() < 1e-6,
                "2s(C4:Major) should be 4/12V, got {}",
                v
            ),
            _ => panic!("Expected Volts"),
        }

        // 7s(C4:Major) -> 8th interval (octave) -> C5 -> 12 semitones -> 1V
        let s: Signal = from_str("\"7s(C4:Major)\"").unwrap();
        match s {
            Signal::Volts(v) => assert!(
                (v - 1.0).abs() < 1e-6,
                "7s(C4:Major) should be 1V, got {}",
                v
            ),
            _ => panic!("Expected Volts"),
        }

        // Cents
        // 1.5s(C4:Major) -> 2nd interval + 50 cents -> 2.5 semitones -> 2.5/12 V
        let s: Signal = from_str("\"1.5s(c4:maj)\"").unwrap();
        match s {
            Signal::Volts(v) => assert!(
                (v - (2.5 / 12.0)).abs() < 1e-6,
                "1.5s(C4:Major) should be 2.5/12V, got {}",
                v
            ),
            _ => panic!("Expected Volts"),
        }

        // Negative degrees wrap to lower octave
        // -1s(C4:Major) -> B3 -> one semitone below C4 -> -1/12 V
        let s: Signal = from_str("\"-1s(C4:Major)\"").unwrap();
        match s {
            Signal::Volts(v) => assert!(
                (v - (-1.0 / 12.0)).abs() < 1e-6,
                "-1s(C4:Major) should be -1/12V, got {}",
                v
            ),
            _ => panic!("Expected Volts"),
        }
    }

    #[test]
    fn test_signal_deserialization_errors() {
        assert!(from_str::<Signal>("\"invalid\"").is_err());
        assert!(from_str::<Signal>("\"-10hz\"").is_err());
    }
}
