/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Synthesizer {
  /** Run the audio thread with cpal */
  constructor()
  stop(): void
  isStopped(): boolean
  sampleRate(): number
  channels(): number
  inputChannels(): number
  getScopes(): Array<[ScopeItem, Float32Array]>
  updatePatch(patch: PatchGraph): Array<ApplyPatchError>
  startRecording(path?: string | undefined | null): string
  stopRecording(): string | null
  isRecording(): boolean
  getHealth(): AudioBudgetSnapshot
  getModuleStates(): Record<string, any>
  /** Force refresh the device cache (call when user clicks "Refresh Devices") */
  refreshDeviceList(): void
  /** List all available audio output devices */
  listAudioOutputDevices(): Array<AudioDeviceInfo>
  /** List all available audio input devices */
  listAudioInputDevices(): Array<AudioDeviceInfo>
  /** Get the current output device name */
  getOutputDeviceName(): string | null
  /** Get the current input device name */
  getInputDeviceName(): string | null
  /**
   * Set the audio output device by name
   * This will stop and recreate the audio stream
   */
  setAudioOutputDevice(deviceName: string): void
  /**
   * Set the audio input device by name
   * This will stop and recreate the input stream
   */
  setAudioInputDevice(deviceName?: string | undefined | null): void
  /** Get the current I/O slot configuration */
  getIoConfig(): AudioIoConfig
  /** Get the current state of all slots (empty, mapped, orphaned) */
  getSlotStates(): AudioSlotStates
  /** Set an input slot mapping */
  setInputSlot(slot: number, deviceName: string, channel: number): void
  /** Set an output slot mapping */
  setOutputSlot(slot: number, deviceName: string, channel: number): void
  /** Clear a slot mapping (input or output) */
  clearSlot(isInput: boolean, slot: number): void
  /** Validate the current slot configuration */
  validateIoConfig(): Array<SlotConfigError>
  /** Validate a provided slot configuration (for preview before applying) */
  validateIoConfigPreview(config: AudioIoConfig): Array<SlotConfigError>
  /**
   * Refresh slot states by checking device availability.
   * Marks slots as Orphaned if their device is no longer available.
   */
  refreshSlotStates(): void
  /** Apply a complete I/O configuration (used for restoring from saved config) */
  applyIoConfig(config: AudioIoConfig): Array<SlotConfigError>
  /** List all available MIDI input ports */
  listMidiInputs(): Array<MidiInputInfo>
  /** Get the currently connected MIDI input port name */
  getMidiInputName(): string | null
  /** Connect to a MIDI input port by name */
  setMidiInput(portName?: string | undefined | null): void
  /**
   * Poll MIDI input and dispatch messages to the audio thread.
   * Call this periodically (e.g., on each animation frame or timer tick).
   */
  pollMidi(): void
}

export interface ApplyPatchError {
  message: string
  errors?: Array<ValidationError>
}

export interface AudioBudgetSnapshot {
  totalSamples: bigint
  totalTimeNs: bigint
  /** Average nanoseconds per sample over snapshot window */
  avgNsPerSample: number
  /** Average real-time usage (1.0 == real-time) */
  avgUsage: number
  /** Worst-case nanoseconds per sample (peak density) */
  peakNsPerSample: number
  /** Worst-case real-time usage (1.0 == real-time) */
  peakUsage: number
}

/** Information about an audio device */
export interface AudioDeviceInfo {
  /** Device name */
  name: string
  /** Number of input channels (0 if output-only) */
  inputChannels: number
  /** Number of output channels (0 if input-only) */
  outputChannels: number
  /** Whether this is the default device */
  isDefault: boolean
  /** Default sample rate in Hz */
  sampleRate: number
}

/** Configuration for all audio I/O slots */
export interface AudioIoConfig {
  /** Input slot mappings (index = slot number) */
  inputSlots: Array<AudioSlotMapping | undefined | null>
  /** Output slot mappings (index = slot number) */
  outputSlots: Array<AudioSlotMapping | undefined | null>
}

/** Mapping of a slot to a specific device channel */
export interface AudioSlotMapping {
  /** Device name */
  deviceName: string
  /** Channel index on the device (0-based) */
  channel: number
}

/** State of an audio slot */
export type AudioSlotState = /** Slot has no mapping assigned */
'Empty'|
/** Slot is mapped to an available device+channel */
'Mapped'|
/** Slot mapping refers to a device that is currently unavailable */
'Orphaned';

/** States for all slots */
export interface AudioSlotStates {
  /** State of each input slot */
  input: Array<AudioSlotState>
  /** State of each output slot */
  output: Array<AudioSlotState>
}

export interface AudioThreadHealthSnapshot {
  estimatedFrameBudgetUsageMax: number
}

/**
 * Parse a mini notation pattern and return all leaf spans.
 *
 * This is used by the Monaco editor to create tracked decorations
 * that move with text edits.
 */
export declare function getMiniLeafSpans(source: string): Array<Array<number>>

/**
 * Analyze a mini notation pattern and return the maximum polyphony needed.
 *
 * Queries 300 cycles (10 min at 120 BPM) and counts the maximum number of simultaneous haps,
 * capping at 16 (the poly voice limit). Logs timing for profiling.
 */
export declare function getPatternPolyphony(source: string): number

export declare function getSchemas(): Array<ModuleSchema>

/** Information about a MIDI input port (for N-API) */
export interface MidiInputInfo {
  name: string
  index: number
}

/** Error type for slot configuration validation */
export interface SlotConfigError {
  message: string
}

/** Detailed validation error for patch validation */
export interface ValidationError {
  field: string
  message: string
  location?: string
}
export interface ModuleIdRemap {
  from: string
  to: string
}

export interface ModuleSchema {
  name: string
  description: string
  paramsSchema: Record<string, unknown>
  outputs: Array<OutputSchema>
  positionalArgs: Array<PositionalArg>
  /** If set, this module always produces exactly this many channels (no inference needed) */
  channels?: number
  /** If set, the name of the parameter that controls channel count */
  channelsParam?: string
  /** If set, the default value for the channels param when not explicitly set */
  channelsParamDefault?: number
}

export interface ModuleState {
  id: string
  moduleType: string
  idIsExplicit?: boolean
  params: any
}

export interface OutputSchema {
  name: string
  description: string
  /** Whether this output is polyphonic (PolyOutput) or monophonic (f32/f64) */
  polyphonic: boolean
  /** Whether this is the default output for the module */
  default: boolean
  /** The minimum value of the raw output range (before any remapping) */
  minValue?: number
  /** The maximum value of the raw output range (before any remapping) */
  maxValue?: number
}

export interface PatchGraph {
  modules: Array<ModuleState>
  moduleIdRemaps?: Array<ModuleIdRemap>
  scopes: Array<Scope>
}

export interface PositionalArg {
  name: string
  optional: boolean
}

export interface Scope {
  item: ScopeItem
  msPerFrame: number
  triggerThreshold?: number
}

export type ScopeItem =
  | { type: 'ModuleOutput', moduleId: string, portName: string }
