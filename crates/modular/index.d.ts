/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Synthesizer {
  /**
   * Create a new Synthesizer with optional audio configuration.
   * If config is provided but invalid (device not found, sample rate unsupported),
   * falls back to OS-preferred host and default devices.
   */
  constructor(config?: AudioConfigOptions | undefined | null)
  stop(): void
  isStopped(): boolean
  sampleRate(): number
  channels(): number
  inputChannels(): number
  getScopes(): Array<[ScopeItem, Array<Float32Array>, ScopeStats]>
  updatePatch(patch: PatchGraph): Array<ApplyPatchError>
  /**
   * Poll and process any pending timing metrics from the audio thread.
   * Should be called periodically from the main thread (e.g., every frame or tick).
   */
  pollMetrics(): void
  /** Get the path to the performance log file */
  getPerfLogPath(): string
  startRecording(path?: string | undefined | null): string
  stopRecording(): string | null
  isRecording(): boolean
  getHealth(): AudioBudgetSnapshot
  getModuleStates(): Record<string, any>
  /** Refresh the device cache (re-enumerates all hosts and devices) */
  refreshDeviceCache(): void
  /** Get the full device cache snapshot */
  getDeviceCache(): DeviceCacheSnapshot
  /** Get the current audio state (host, devices, sample rate, etc.) */
  getCurrentAudioState(): CurrentAudioState
  /**
   * Recreate both input and output streams with new device/config
   * This is the primary way to change audio devices after initialization
   */
  recreateStreams(outputDeviceId: string, sampleRate: number, bufferSize?: number | undefined | null, inputDeviceId?: string | undefined | null): void
  /** Force refresh the device cache (legacy - same as refresh_device_cache) */
  refreshDeviceList(): void
  /** List all available audio hosts (from cache) */
  listAudioHosts(): Array<HostInfo>
  /** List all available audio output devices (from cache) */
  listAudioOutputDevices(): Array<AudioDeviceInfo>
  /** List all available audio input devices (from cache) */
  listAudioInputDevices(): Array<AudioDeviceInfo>
  /** Get the current output device ID */
  getOutputDeviceId(): string | null
  /** Get the current input device ID */
  getInputDeviceId(): string | null
  /**
   * Set the audio output device (legacy - use recreate_streams instead)
   * This uses device default sample rate and buffer size
   */
  setAudioOutputDevice(deviceId: string): void
  /** Set the audio input device (legacy - use recreate_streams instead) */
  setAudioInputDevice(deviceId?: string | undefined | null): void
  /** List all available MIDI input ports */
  listMidiInputs(): Array<MidiInputInfo>
  /** Get the currently connected MIDI input port name (first port for backward compatibility) */
  getMidiInputName(): string | null
  /** Get all currently connected MIDI input port names */
  getMidiInputNames(): Array<string>
  /** Connect to a MIDI input port by name (for manual/backward-compatible use) */
  setMidiInput(portName?: string | undefined | null): void
  /**
   * Attempt to reconnect to any MIDI devices that were configured but disconnected.
   * Call this periodically if you want hot-plug support.
   * Note: MIDI messages are polled automatically in the audio thread.
   */
  tryReconnectMidi(): void
}

export interface ApplyPatchError {
  message: string
  errors?: Array<ValidationError>
}

export interface AudioBudgetSnapshot {
  totalSamples: bigint
  totalTimeNs: bigint
  /** Average nanoseconds per sample over snapshot window */
  avgNsPerSample: number
  /** Average real-time usage (1.0 == real-time) */
  avgUsage: number
  /** Worst-case nanoseconds per sample (peak density) */
  peakNsPerSample: number
  /** Worst-case real-time usage (1.0 == real-time) */
  peakUsage: number
}

/** Audio configuration for synthesizer initialization */
export interface AudioConfigOptions {
  hostId?: string
  outputDeviceId?: string
  inputDeviceId?: string
  sampleRate?: number
  bufferSize?: number
}

/** Information about an audio device */
export interface AudioDeviceInfo {
  /** Stable Device ID */
  id: string
  /** Host ID this device belongs to */
  hostId: string
  /** Device name */
  name: string
  /** Number of input channels (0 if output-only) */
  inputChannels: number
  /** Number of output channels (0 if input-only) */
  outputChannels: number
  /** Whether this is the default device for this host */
  isDefault: boolean
  /** Default sample rate in Hz */
  sampleRate: number
  /** Supported sample rates (common rates that the device supports) */
  supportedSampleRates: Array<number>
  /** Buffer size range (min/max), or None if unknown */
  bufferSizeRange?: BufferSizeRange
}

export interface AudioThreadHealthSnapshot {
  estimatedFrameBudgetUsageMax: number
}

/** Buffer size range for an audio device */
export interface BufferSizeRange {
  min: number
  max: number
}

/** Current audio state information */
export interface CurrentAudioState {
  hostId: string
  outputDeviceId?: string
  outputDeviceName?: string
  inputDeviceId?: string
  inputDeviceName?: string
  sampleRate: number
  bufferSize?: number
  outputChannels: number
  inputChannels: number
  fallbackWarning?: string
}

/**
 * Derive the output channel count for a module from its params JSON.
 *
 * Returns the derived channel count, or null if the module type is unknown
 * or the channel count cannot be determined from the params.
 */
export declare function deriveChannelCount(moduleType: string, params: any): number | null

/** N-API compatible structure for the full device cache */
export interface DeviceCacheSnapshot {
  /** All hosts with their devices grouped together */
  hosts: Array<HostDeviceInfo>
}

/**
 * Parse a mini notation pattern and return all leaf spans.
 *
 * This is used by the Monaco editor to create tracked decorations
 * that move with text edits.
 */
export declare function getMiniLeafSpans(source: string): Array<Array<number>>

/**
 * Analyze a mini notation pattern and return the maximum polyphony needed.
 *
 * Queries 300 cycles (10 min at 120 BPM) and counts the maximum number of simultaneous haps,
 * capping at 16 (the poly voice limit). Logs timing for profiling.
 */
export declare function getPatternPolyphony(source: string): number

export declare function getSchemas(): Array<ModuleSchema>

/** Per-host device info for the cache snapshot */
export interface HostDeviceInfo {
  hostId: string
  hostName: string
  outputDevices: Array<AudioDeviceInfo>
  inputDevices: Array<AudioDeviceInfo>
}

/** Information about an audio host */
export interface HostInfo {
  /** Host identifier (e.g., "CoreAudio", "WASAPI", "ALSA") */
  id: string
  /** Human-readable host name */
  name: string
}

/** Information about a MIDI input port (for N-API) */
export interface MidiInputInfo {
  name: string
  index: number
}

/** Detailed validation error for patch validation */
export interface ValidationError {
  field: string
  message: string
  location?: string
  /** Human-readable description of expected input type */
  expectedType?: string
  /** JSON snippet of the actual value that failed */
  actualValue?: string
}
export interface ModuleIdRemap {
  from: string
  to: string
}

export interface ModuleSchema {
  name: string
  description: string
  paramsSchema: Record<string, unknown>
  outputs: Array<OutputSchema>
  positionalArgs: Array<PositionalArg>
  /** If set, this module always produces exactly this many channels (no inference needed) */
  channels?: number
  /** If set, the name of the parameter that controls channel count */
  channelsParam?: string
  /** If set, the default value for the channels param when not explicitly set */
  channelsParamDefault?: number
}

export interface ModuleState {
  id: string
  moduleType: string
  idIsExplicit?: boolean
  params: any
}

export interface OutputSchema {
  name: string
  description: string
  /** Whether this output is polyphonic (PolyOutput) or monophonic (f32/f64) */
  polyphonic: boolean
  /** Whether this is the default output for the module */
  default: boolean
  /** The minimum value of the raw output range (before any remapping) */
  minValue?: number
  /** The maximum value of the raw output range (before any remapping) */
  maxValue?: number
}

export interface PatchGraph {
  modules: Array<ModuleState>
  moduleIdRemaps?: Array<ModuleIdRemap>
  scopes: Array<Scope>
}

export interface PositionalArg {
  name: string
  optional: boolean
}

export interface Scope {
  item: ScopeItem
  msPerFrame: number
  triggerThreshold?: number
  /** Voltage scale for display (default 5.0). The scope displays from -scale to +scale. */
  scale: number
}

export type ScopeItem =
  | { type: 'ModuleOutput', moduleId: string, portName: string }

/** Statistics computed from scope buffer data */
export interface ScopeStats {
  min: number
  max: number
  peakToPeak: number
}
