import {
    app,
    BrowserWindow,
    ipcMain,
    dialog,
    Menu,
    shell,
    MenuItem,
} from 'electron';
import {
    getSchemas,
    getMiniLeafSpans,
    PatchGraph,
    Synthesizer,
    AudioConfigOptions,
} from '@modular/core';
import {
    IPC_CHANNELS,
    IPCHandlers,
    FileTreeEntry,
    MENU_CHANNELS,
    ContextMenuOptions,
    DSLExecuteResult,
    MainLogLevel,
    MainLogEntry,
} from './ipcTypes';
import { reconcilePatchBySimilarity } from './patchSimilarityRemap';
import { executePatchScript } from './dsl/executor';
import { buildLibSource } from './dsl/typescriptLibGen';
import * as fs from 'fs';
import * as path from 'path';
import { z } from 'zod';
import { updateElectronApp } from 'update-electron-app';

updateElectronApp();

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundered app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Declare mainWindow early so log forwarding can reference it
let mainWindow: BrowserWindow | null = null;

// ========================================================================
// Main Process Log Forwarding
// ========================================================================
// Queue logs until the renderer is ready, then forward all logs to renderer
const pendingLogEntries: MainLogEntry[] = [];
let rendererReady = false;

function sendLogToRenderer(entry: MainLogEntry) {
    if (mainWindow && !mainWindow.isDestroyed() && rendererReady) {
        mainWindow.webContents.send(IPC_CHANNELS.MAIN_LOG, entry);
    } else {
        // Queue log entries until renderer is ready
        pendingLogEntries.push(entry);
    }
}

function flushPendingLogs() {
    if (mainWindow && !mainWindow.isDestroyed()) {
        rendererReady = true;
        for (const entry of pendingLogEntries) {
            mainWindow.webContents.send(IPC_CHANNELS.MAIN_LOG, entry);
        }
        pendingLogEntries.length = 0;
    }
}

// Intercept console methods to forward to renderer
const originalConsole = {
    log: console.log.bind(console),
    info: console.info.bind(console),
    warn: console.warn.bind(console),
    error: console.error.bind(console),
    debug: console.debug.bind(console),
};

function createLogInterceptor(level: MainLogLevel) {
    return (...args: unknown[]) => {
        // Always call original console method first
        originalConsole[level](...args);
        
        // Forward to renderer (serialize args to handle non-transferable values)
        const entry: MainLogEntry = {
            level,
            timestamp: Date.now(),
            args: args.map(arg => serializeForIPC(arg)),
        };
        sendLogToRenderer(entry);
    };
}

/**
 * Serialize a value for IPC transfer, handling non-transferable types
 */
function serializeForIPC(value: unknown, seen = new WeakSet<object>()): unknown {
    // Handle primitives
    if (value === null || value === undefined) {
        return value;
    }
    
    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
        return value;
    }
    
    // Handle BigInt by converting to string with 'n' suffix for clarity
    if (typeof value === 'bigint') {
        return `${value}n`;
    }
    
    // Handle symbols
    if (typeof value === 'symbol') {
        return value.toString();
    }
    
    // Handle functions
    if (typeof value === 'function') {
        return `[Function: ${value.name || 'anonymous'}]`;
    }
    
    // Handle Error objects specially
    if (value instanceof Error) {
        return { __error: true, name: value.name, message: value.message, stack: value.stack };
    }
    
    // Handle objects and arrays
    if (typeof value === 'object') {
        // Detect circular references
        if (seen.has(value)) {
            return '[Circular]';
        }
        seen.add(value);
        
        // Handle arrays
        if (Array.isArray(value)) {
            return value.map(item => serializeForIPC(item, seen));
        }
        
        // Handle Date
        if (value instanceof Date) {
            return value.toISOString();
        }
        
        // Handle Map
        if (value instanceof Map) {
            const obj: Record<string, unknown> = { __type: 'Map' };
            for (const [k, v] of value) {
                obj[String(k)] = serializeForIPC(v, seen);
            }
            return obj;
        }
        
        // Handle Set
        if (value instanceof Set) {
            return { __type: 'Set', values: Array.from(value).map(v => serializeForIPC(v, seen)) };
        }
        
        // Handle plain objects
        const result: Record<string, unknown> = {};
        for (const key of Object.keys(value)) {
            result[key] = serializeForIPC((value as Record<string, unknown>)[key], seen);
        }
        return result;
    }
    
    // Fallback
    return String(value);
}

console.log = createLogInterceptor('log');
console.info = createLogInterceptor('info');
console.warn = createLogInterceptor('warn');
console.error = createLogInterceptor('error');
console.debug = createLogInterceptor('debug');

// ========================================================================

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
    app.quit();
}

// Enforce single instance
const gotTheLock = app.requestSingleInstanceLock();
if (!gotTheLock) {
    app.quit();
} else {
    app.on('second-instance', () => {
        // Focus the existing window if someone tries to open a second instance
        const windows = BrowserWindow.getAllWindows();
        if (windows.length > 0) {
            const mainWindow = windows[0];
            if (mainWindow.isMinimized()) mainWindow.restore();
            mainWindow.focus();
        }
    });
}

// Config persistence - defined early so we can load before synth creation
let CONFIG_FILE: string;
try {
    CONFIG_FILE = path.join(app.getPath('userData'), 'config.json');
} catch (error) {
    console.error('Error determining config file path:', error);
    CONFIG_FILE = 'config.json';
}

const AppConfigSchema = z.object({
    theme: z.string().optional(),
    cursorStyle: z
        .enum([
            'line',
            'block',
            'underline',
            'line-thin',
            'block-outline',
            'underline-thin',
        ])
        .optional(),
    lastOpenedFolder: z.string().optional(),
    audioConfig: z.object({
        hostId: z.string().optional(),
        inputDeviceId: z.string().nullable().optional(),
        outputDeviceId: z.string().optional(),
        sampleRate: z.number().optional(),
        bufferSize: z.number().optional(),
    }).optional(),
});

type AppConfig = z.infer<typeof AppConfigSchema>;

function loadConfig(): AppConfig {
    try {
        if (fs.existsSync(CONFIG_FILE)) {
            const data = fs.readFileSync(CONFIG_FILE, 'utf-8');
            const json = JSON.parse(data);
            const result = AppConfigSchema.safeParse(json);
            if (result.success) {
                return result.data;
            } else {
                console.error('Config validation failed:', result.error);
            }
        }
    } catch (error) {
        console.error('Error loading config:', error);
    }
    return {};
}

function saveConfig(config: AppConfig) {
    try {
        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2), 'utf-8');
    } catch (error) {
        console.error('Error saving config:', error);
    }
}

// Load saved config to pass to synthesizer
const savedConfig = loadConfig();
const audioConfigOptions: AudioConfigOptions | undefined = savedConfig.audioConfig ? {
    hostId: savedConfig.audioConfig.hostId ?? undefined,
    outputDeviceId: savedConfig.audioConfig.outputDeviceId ?? undefined,
    inputDeviceId: savedConfig.audioConfig.inputDeviceId ?? undefined,
    sampleRate: savedConfig.audioConfig.sampleRate ?? undefined,
    bufferSize: savedConfig.audioConfig.bufferSize ?? undefined,
} : undefined;

// Initialize the synthesizer instance with saved config
console.log('Initializing Synthesizer with config:', audioConfigOptions);
const synth = new Synthesizer(audioConfigOptions);

// Get the actual audio state after construction (may have fallen back to defaults)
const actualAudioState = synth.getCurrentAudioState();
console.log('Actual audio state after construction:', actualAudioState);

// Check for fallback warning and update saved config if devices changed
if (actualAudioState.fallbackWarning) {
    console.warn('Audio device fallback occurred:', actualAudioState.fallbackWarning);
}

// Update saved config with actual devices used (in case of fallback)
const actualConfig = loadConfig();
const configNeedsUpdate = 
    actualConfig.audioConfig?.hostId !== actualAudioState.hostId ||
    actualConfig.audioConfig?.outputDeviceId !== actualAudioState.outputDeviceId ||
    actualConfig.audioConfig?.inputDeviceId !== actualAudioState.inputDeviceId ||
    actualConfig.audioConfig?.sampleRate !== actualAudioState.sampleRate ||
    actualConfig.audioConfig?.bufferSize !== actualAudioState.bufferSize;

if (configNeedsUpdate) {
    actualConfig.audioConfig = {
        hostId: actualAudioState.hostId,
        outputDeviceId: actualAudioState.outputDeviceId ?? undefined,
        inputDeviceId: actualAudioState.inputDeviceId ?? null,
        sampleRate: actualAudioState.sampleRate,
        bufferSize: actualAudioState.bufferSize ?? undefined,
    };
    saveConfig(actualConfig);
    console.log('Saved updated audio config after fallback');
}

// Save audio configuration to config file
function saveAudioConfig() {
    try {
        const config = loadConfig();
        const state = synth.getCurrentAudioState();
        
        config.audioConfig = {
            hostId: state.hostId,
            outputDeviceId: state.outputDeviceId ?? undefined,
            inputDeviceId: state.inputDeviceId ?? null,
            sampleRate: state.sampleRate,
            bufferSize: state.bufferSize ?? undefined,
        };

        saveConfig(config);
        console.log('Audio configuration saved');
    } catch (error) {
        console.error('Error saving audio config:', error);
    }
}

setInterval(() => {
    // Keep the audio thread alive
    console.log('health:', synth.getHealth());
}, 10000);

// Workspace root state
let currentWorkspaceRoot: string | null = null;

// File watcher for config changes
let configWatcher: fs.FSWatcher | null = null;

function ensureConfigExists() {
    if (!fs.existsSync(CONFIG_FILE)) {
        const defaultConfig: AppConfig = {
            theme: 'modular-dark',
            cursorStyle: 'block',
        };
        saveConfig(defaultConfig);
    }
}

function startConfigWatcher() {
    if (configWatcher) {
        configWatcher.close();
    }

    ensureConfigExists();

    // Watch for config file changes
    configWatcher = fs.watch(CONFIG_FILE, (eventType) => {
        if (eventType === 'change') {
            const config = loadConfig();
            // Send updated config to renderer
            if (mainWindow && !mainWindow.isDestroyed()) {
                mainWindow.webContents.send(
                    IPC_CHANNELS.CONFIG_ON_CHANGE,
                    config,
                );
            }
        }
    });
}

// Patch reconciliation state (reset when a different file/buffer is evaluated)
let lastAppliedPatchGraph: PatchGraph | null = null;
let lastAppliedSourceId: string | null = null;

const DEBUG_LOG =
    process.env.MODULAR_DEBUG_LOG === '1' ||
    process.env.MODULAR_DEBUG_LOG === 'true';

const PATCH_REMAP_THRESHOLD = process.env.MODULAR_PATCH_REMAP_THRESHOLD
    ? Number(process.env.MODULAR_PATCH_REMAP_THRESHOLD)
    : undefined;
const PATCH_REMAP_MARGIN = process.env.MODULAR_PATCH_REMAP_MARGIN
    ? Number(process.env.MODULAR_PATCH_REMAP_MARGIN)
    : undefined;

console.log('Patch remap debug mode:', DEBUG_LOG);

/**
 * Validate that a path is valid (absolute or relative to workspace)
 */
function validatePathInWorkspace(filePath: string): string | null {
    if (path.isAbsolute(filePath)) {
        return filePath;
    }

    if (!currentWorkspaceRoot) {
        return null;
    }

    return path.resolve(currentWorkspaceRoot, filePath);
}

/**
 * Check if a file should be included (only .js and .mjs files)
 */
function isJavaScriptFile(filename: string): boolean {
    return filename.endsWith('.js') || filename.endsWith('.mjs');
}

/**
 * Recursively build file tree for JavaScript files
 */
function buildFileTree(
    dirPath: string,
    relativePath: string = '',
): FileTreeEntry[] {
    const entries: FileTreeEntry[] = [];

    try {
        const items = fs.readdirSync(dirPath, { withFileTypes: true });

        for (const item of items) {
            // Skip hidden files and node_modules
            if (item.name.startsWith('.') || item.name === 'node_modules') {
                continue;
            }

            const itemRelativePath = relativePath
                ? `${relativePath}/${item.name}`
                : item.name;
            const itemAbsolutePath = path.join(dirPath, item.name);

            if (item.isDirectory()) {
                const children = buildFileTree(
                    itemAbsolutePath,
                    itemRelativePath,
                );
                if (children.length > 0) {
                    entries.push({
                        name: item.name,
                        path: itemRelativePath,
                        type: 'directory',
                        children,
                    });
                }
            } else if (item.isFile() && isJavaScriptFile(item.name)) {
                entries.push({
                    name: item.name,
                    path: itemRelativePath,
                    type: 'file',
                });
            }
        }
    } catch (error) {
        console.error('Error reading directory:', dirPath, error);
    }

    // Sort: directories first, then files, alphabetically
    return entries.sort((a, b) => {
        if (a.type !== b.type) {
            return a.type === 'directory' ? -1 : 1;
        }
        return a.name.localeCompare(b.name);
    });
}

/**
 * Type-safe IPC handler registration
 */
function registerIPCHandler<T extends keyof typeof IPC_CHANNELS>(
    channel: T,
    handler: IPCHandlers[(typeof IPC_CHANNELS)[T]],
) {
    ipcMain.handle(IPC_CHANNELS[channel], async (_event, ...args) => {
        try {
            // @ts-ignore - TypeScript has trouble with the variadic handler signatures
            const ret = handler(...args);
            if (ret instanceof Promise) {
                return await ret;
            }
            return ret;
        } catch (error) {
            console.error(`Error in IPC handler ${channel}:`, error);
            throw error;
        }
    });
}

// Register all IPC handlers
registerIPCHandler('GET_SCHEMAS', () => {
    return getSchemas();
});

// DSL lib source for Monaco autocomplete - cached since schemas don't change at runtime
let cachedLibSource: string | null = null;
registerIPCHandler('GET_DSL_LIB_SOURCE', () => {
    if (!cachedLibSource) {
        cachedLibSource = buildLibSource(getSchemas());
    }
    return cachedLibSource;
});

// DSL execution in main process with direct N-API access
registerIPCHandler('DSL_EXECUTE', (source, sourceId): DSLExecuteResult => {
    try {
        const schemas = getSchemas();
        const { patch, sourceLocationMap, interpolationResolutions } = executePatchScript(source, schemas);
        patch.moduleIdRemaps = [];

        // Convert Map to Record for IPC serialization
        const sourceLocationRecord: Record<string, { line: number; column: number; idIsExplicit: boolean }> = {};
        for (const [moduleId, loc] of sourceLocationMap) {
            sourceLocationRecord[moduleId] = loc;
        }

        // Convert interpolation resolutions Map to Record for IPC serialization
        const interpolationResolutionsRecord: Record<string, any[]> = {};
        for (const [key, resolutions] of interpolationResolutions) {
            interpolationResolutionsRecord[key] = resolutions;
        }

        // Requirement: assume a full change when a different file/buffer is evaluated.
        const shouldReconcile = !!sourceId && lastAppliedSourceId === sourceId;

        if (DEBUG_LOG) {
            if (!sourceId) {
                console.log('[patch-remap] no sourceId; reconciliation disabled');
            } else if (!shouldReconcile) {
                console.log(
                    `[patch-remap] source changed (${lastAppliedSourceId ?? 'none'} -> ${sourceId}); reconciliation disabled`,
                );
            } else {
                console.log(`[patch-remap] reconciling for sourceId=${sourceId}`);
            }
        }

        const { moduleIdRemap } = reconcilePatchBySimilarity(
            patch,
            shouldReconcile ? lastAppliedPatchGraph : null,
            {
                matchThreshold: PATCH_REMAP_THRESHOLD,
                ambiguityMargin: PATCH_REMAP_MARGIN,
                debugLog: DEBUG_LOG ? (message) => console.log(message) : undefined,
            },
        );

        if (DEBUG_LOG) {
            const remapCount = Object.keys(moduleIdRemap).length;
            const thresholdInfo =
                PATCH_REMAP_THRESHOLD !== undefined
                    ? PATCH_REMAP_THRESHOLD.toFixed(4)
                    : 'default';
            const marginInfo =
                PATCH_REMAP_MARGIN !== undefined
                    ? PATCH_REMAP_MARGIN.toFixed(4)
                    : 'default';
            console.log(
                `[patch-remap] summary shouldReconcile=${shouldReconcile} remaps=${remapCount} threshold=${thresholdInfo} margin=${marginInfo}`,
            );
        }

        // Send remap hints along with the desired patch
        patch.moduleIdRemaps = Object.entries(moduleIdRemap).map(([from, to]) => ({
            from,
            to,
        }));

        const errors = synth.updatePatch(patch);

        if (errors.length === 0) {
            lastAppliedPatchGraph = patch;
            lastAppliedSourceId = sourceId ?? null;
        }

        if (errors.length > 0) {
            return {
                success: false,
                errors,
                appliedPatch: patch,
                moduleIdRemap,
                sourceLocationMap: sourceLocationRecord,
                interpolationResolutions: interpolationResolutionsRecord,
            };
        }

        return {
            success: true,
            errors: [],
            appliedPatch: patch,
            moduleIdRemap,
            sourceLocationMap: sourceLocationRecord,
            interpolationResolutions: interpolationResolutionsRecord,
        };
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return {
            success: false,
            errorMessage,
        };
    }
});

registerIPCHandler('SYNTH_GET_SAMPLE_RATE', () => {
    return synth.sampleRate();
});

registerIPCHandler('SYNTH_GET_CHANNELS', () => {
    return synth.channels();
});

registerIPCHandler('SYNTH_GET_SCOPES', () => {
    return synth.getScopes();
});

registerIPCHandler('SYNTH_GET_MODULE_STATES', () => {
    return synth.getModuleStates();
});

registerIPCHandler('GET_MINI_LEAF_SPANS', (source) => {
    return getMiniLeafSpans(source);
});

registerIPCHandler('SYNTH_UPDATE_PATCH', (patch, sourceId) => {
    // Requirement: assume a full change when a different file/buffer is evaluated.
    const shouldReconcile = !!sourceId && lastAppliedSourceId === sourceId;

    if (DEBUG_LOG) {
        if (!sourceId) {
            console.log('[patch-remap] no sourceId; reconciliation disabled');
        } else if (!shouldReconcile) {
            console.log(
                `[patch-remap] source changed (${lastAppliedSourceId ?? 'none'} -> ${sourceId}); reconciliation disabled`,
            );
        } else {
            console.log(`[patch-remap] reconciling for sourceId=${sourceId}`);
        }
    }

    const { moduleIdRemap } = reconcilePatchBySimilarity(
        patch,
        shouldReconcile ? lastAppliedPatchGraph : null,
        {
            matchThreshold: PATCH_REMAP_THRESHOLD,
            ambiguityMargin: PATCH_REMAP_MARGIN,
            debugLog: DEBUG_LOG ? (message) => console.log(message) : undefined,
        },
    );

    if (DEBUG_LOG) {
        const remapCount = Object.keys(moduleIdRemap).length;
        const thresholdInfo =
            PATCH_REMAP_THRESHOLD !== undefined
                ? PATCH_REMAP_THRESHOLD.toFixed(4)
                : 'default';
        const marginInfo =
            PATCH_REMAP_MARGIN !== undefined
                ? PATCH_REMAP_MARGIN.toFixed(4)
                : 'default';
        console.log(
            `[patch-remap] summary shouldReconcile=${shouldReconcile} remaps=${remapCount} threshold=${thresholdInfo} margin=${marginInfo}`,
        );
    }

    // Send remap hints along with the desired patch; Rust will use them to
    // preserve module instances while keeping the desired ids.
    patch.moduleIdRemaps = Object.entries(moduleIdRemap).map(([from, to]) => ({
        from,
        to,
    }));

    const errors = synth.updatePatch(patch);

    if (errors.length === 0) {
        lastAppliedPatchGraph = patch;
        lastAppliedSourceId = sourceId ?? null;
    }

    return { errors, appliedPatch: patch, moduleIdRemap };
});

registerIPCHandler('SYNTH_START_RECORDING', (path) => {
    return synth.startRecording(path);
});

registerIPCHandler('SYNTH_STOP_RECORDING', () => {
    return synth.stopRecording();
});

registerIPCHandler('SYNTH_IS_RECORDING', () => {
    return synth.isRecording();
});

registerIPCHandler('SYNTH_GET_HEALTH', () => {
    return synth.getHealth();
});

registerIPCHandler('SYNTH_STOP', () => {
    synth.stop();
});

registerIPCHandler('SYNTH_IS_STOPPED', () => {
    return synth.isStopped();
});

// Audio device operations - new API
registerIPCHandler('AUDIO_REFRESH_DEVICE_CACHE', () => {
    synth.refreshDeviceCache();
});

registerIPCHandler('AUDIO_GET_DEVICE_CACHE', () => {
    return synth.getDeviceCache();
});

registerIPCHandler('AUDIO_GET_CURRENT_STATE', () => {
    return synth.getCurrentAudioState();
});

registerIPCHandler('AUDIO_RECREATE_STREAMS', (
    outputDeviceId: string,
    sampleRate: number,
    bufferSize: number | null,
    inputDeviceId: string | null,
) => {
    synth.recreateStreams(outputDeviceId, sampleRate, bufferSize ?? undefined, inputDeviceId ?? undefined);
    saveAudioConfig();
});

// Legacy audio device operations (for backward compatibility)
registerIPCHandler('AUDIO_REFRESH_DEVICE_LIST', () => {
    synth.refreshDeviceList();
});

registerIPCHandler('AUDIO_LIST_HOSTS', () => {
    return synth.listAudioHosts();
});

registerIPCHandler('AUDIO_LIST_OUTPUT_DEVICES', () => {
    return synth.listAudioOutputDevices();
});

registerIPCHandler('AUDIO_LIST_INPUT_DEVICES', () => {
    return synth.listAudioInputDevices();
});

registerIPCHandler('AUDIO_GET_OUTPUT_DEVICE', () => {
    return synth.getOutputDeviceId();
});

registerIPCHandler('AUDIO_GET_INPUT_DEVICE', () => {
    return synth.getInputDeviceId();
});

registerIPCHandler('AUDIO_SET_OUTPUT_DEVICE', (deviceId: string) => {
    synth.setAudioOutputDevice(deviceId);
    saveAudioConfig();
});

registerIPCHandler('AUDIO_SET_INPUT_DEVICE', (deviceId: string | null) => {
    synth.setAudioInputDevice(deviceId ?? undefined);
    saveAudioConfig();
});

registerIPCHandler('AUDIO_GET_INPUT_CHANNELS', () => {
    return synth.inputChannels();
});

// MIDI device operations
registerIPCHandler('MIDI_LIST_INPUTS', () => {
    return synth.listMidiInputs();
});

registerIPCHandler('MIDI_GET_INPUT', () => {
    return synth.getMidiInputName();
});

registerIPCHandler('MIDI_SET_INPUT', (portName: string | null) => {
    synth.setMidiInput(portName ?? undefined);
});

registerIPCHandler('MIDI_TRY_RECONNECT', () => {
    synth.tryReconnectMidi();
});

registerIPCHandler('SHOW_CONTEXT_MENU', (options: ContextMenuOptions) => {
    // We import Menu, MenuItem dynamically or assume they are available if imported at top
    // Since imports are top-level, we can use them.
    const menu = new Menu();
    const webContents = BrowserWindow.getAllWindows()[0]?.webContents;

    if (!webContents) return;

    if (options.type === 'untitled') {
        menu.append(
            new MenuItem({
                label: 'Save',
                click: () =>
                    webContents.send(IPC_CHANNELS.ON_CONTEXT_MENU_COMMAND, {
                        command: 'save',
                        bufferId: options.bufferId,
                    }),
            }),
        );
    } else if (options.type === 'file' || options.type === 'directory') {
        const filePath = options.path;

        if (options.type === 'file') {
            if (options.isOpenBuffer) {
                menu.append(
                    new MenuItem({
                        label: 'Save',
                        click: () =>
                            webContents.send(
                                IPC_CHANNELS.ON_CONTEXT_MENU_COMMAND,
                                { command: 'save', bufferId: options.bufferId },
                            ),
                    }),
                );
                menu.append(new MenuItem({ type: 'separator' }));
            }
        }

        menu.append(
            new MenuItem({
                label: 'Rename...',
                click: () =>
                    webContents.send(IPC_CHANNELS.ON_CONTEXT_MENU_COMMAND, {
                        command: 'rename',
                        path: options.path,
                        bufferId: options.bufferId,
                    }),
            }),
        );

        menu.append(
            new MenuItem({
                label: 'Delete',
                click: () =>
                    webContents.send(IPC_CHANNELS.ON_CONTEXT_MENU_COMMAND, {
                        command: 'delete',
                        path: options.path,
                        bufferId: options.bufferId,
                    }),
            }),
        );

        menu.append(new MenuItem({ type: 'separator' }));
        menu.append(
            new MenuItem({
                label: 'Reveal in Finder/Explorer',
                click: () => {
                    if (filePath) {
                        const absPath = validatePathInWorkspace(filePath);
                        if (absPath) shell.showItemInFolder(absPath);
                    }
                },
            }),
        );
    }

    menu.popup();
});

// Filesystem IPC handlers
// @ts-ignore - async handler returns Promise
registerIPCHandler('FS_SELECT_WORKSPACE', async () => {
    const properties: Electron.OpenDialogOptions['properties'] = [
        'openDirectory',
    ];

    // Add 'createDirectory' for macOS or 'promptToCreate' for Windows if needed
    if (process.platform === 'darwin') {
        properties.push('createDirectory'); // Allows creating new directories from the dialog on macOS
    } else if (process.platform === 'win32') {
        // Note: promptToCreate on Windows prompts for creation if the path doesn't exist,
        // but doesn't handle the actual creation, which must be done by your app.
        properties.push('promptToCreate');
    }
    const result = await dialog.showOpenDialog({
        properties,
    });

    if (result.canceled || result.filePaths.length === 0) {
        return null;
    }

    currentWorkspaceRoot = result.filePaths[0];
    console.log('Workspace selected:', currentWorkspaceRoot);

    // Save to config
    saveConfig({ lastOpenedFolder: currentWorkspaceRoot });

    return { path: currentWorkspaceRoot };
});

registerIPCHandler('FS_GET_WORKSPACE', () => {
    return currentWorkspaceRoot ? { path: currentWorkspaceRoot } : null;
});

registerIPCHandler('FS_LIST_FILES', () => {
    if (!currentWorkspaceRoot) {
        return [];
    }
    return buildFileTree(currentWorkspaceRoot);
});

registerIPCHandler('FS_READ_FILE', (relativePath) => {
    const absolutePath = validatePathInWorkspace(relativePath);
    if (!absolutePath) {
        throw new Error('Invalid file path or no workspace selected');
    }

    try {
        return fs.readFileSync(absolutePath, 'utf-8');
    } catch (error) {
        console.error('Error reading file:', error);
        throw new Error(`Failed to read file: ${relativePath}`);
    }
});

registerIPCHandler('FS_WRITE_FILE', (relativePath, content) => {
    const absolutePath = validatePathInWorkspace(relativePath);
    if (!absolutePath) {
        return {
            success: false,
            error: 'Invalid file path or no workspace selected',
        };
    }

    try {
        // Ensure directory exists
        const dir = path.dirname(absolutePath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(absolutePath, content, 'utf-8');
        return { success: true };
    } catch (error) {
        console.error('Error writing file:', error);
        return {
            success: false,
            error: `Failed to write file: ${relativePath}`,
        };
    }
});

registerIPCHandler('FS_RENAME_FILE', (oldPath, newPath) => {
    const oldAbsolutePath = validatePathInWorkspace(oldPath);
    const newAbsolutePath = validatePathInWorkspace(newPath);

    if (!oldAbsolutePath || !newAbsolutePath) {
        return {
            success: false,
            error: 'Invalid file path or no workspace selected',
        };
    }

    try {
        // Ensure target directory exists
        const dir = path.dirname(newAbsolutePath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        // Check for collision
        if (fs.existsSync(newAbsolutePath)) {
            // Check if it's the same file (e.g. case-only rename on case-insensitive FS)
            try {
                const oldStat = fs.statSync(oldAbsolutePath);
                const newStat = fs.statSync(newAbsolutePath);
                // If inodes coincide, it's the same file, so allow rename (case change)
                if (oldStat.ino !== newStat.ino) {
                    return {
                        success: false,
                        error: 'A file with that name already exists.',
                    };
                }
            } catch (e) {
                // If we can't verify, be safe and prevent overwrite
                return {
                    success: false,
                    error: 'A file with that name already exists.',
                };
            }
        }

        fs.renameSync(oldAbsolutePath, newAbsolutePath);
        return { success: true };
    } catch (error) {
        console.error('Error renaming file:', error);
        return { success: false, error: `Failed to rename file: ${oldPath}` };
    }
});

registerIPCHandler('FS_DELETE_FILE', async (absolutePath) => {
    try {
        await shell.trashItem(absolutePath);
        return { success: true };
    } catch (error) {
        console.error('Error deleting file:', error);
        return { success: false, error: `Failed to delete: ${absolutePath}` };
    }
});

registerIPCHandler('FS_MOVE_FILE', (sourcePath, destPath) => {
    const sourceAbsolutePath = validatePathInWorkspace(sourcePath);
    const destAbsolutePath = validatePathInWorkspace(destPath);

    if (!sourceAbsolutePath || !destAbsolutePath) {
        return {
            success: false,
            error: 'Invalid file path or no workspace selected',
        };
    }

    try {
        // Ensure target directory exists
        const dir = path.dirname(destAbsolutePath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.renameSync(sourceAbsolutePath, destAbsolutePath);
        return { success: true };
    } catch (error) {
        console.error('Error moving file:', error);
        return { success: false, error: `Failed to move file: ${sourcePath}` };
    }
});

registerIPCHandler('FS_CREATE_FOLDER', (relativePath) => {
    const absolutePath = validatePathInWorkspace(relativePath);
    if (!absolutePath) {
        return {
            success: false,
            error: 'Invalid folder path or no workspace selected',
        };
    }

    try {
        fs.mkdirSync(absolutePath, { recursive: true });
        return { success: true };
    } catch (error) {
        console.error('Error creating folder:', error);
        return {
            success: false,
            error: `Failed to create folder: ${relativePath}`,
        };
    }
});

// @ts-ignore - async handler returns Promise
registerIPCHandler('FS_SHOW_SAVE_DIALOG', async (defaultPath?: string) => {
    console.log('defaultPath:', defaultPath);
    const result = await dialog.showSaveDialog({
        defaultPath: defaultPath || 'untitled.mjs',
        filters: [
            { name: 'JavaScript Files', extensions: ['js', 'mjs'] },
            { name: 'All Files', extensions: ['*'] },
        ],
    });

    if (result.canceled || !result.filePath) {
        return null;
    }

    // Return relative path if within workspace, otherwise absolute
    if (
        currentWorkspaceRoot &&
        result.filePath.startsWith(currentWorkspaceRoot)
    ) {
        return path.relative(currentWorkspaceRoot, result.filePath);
    }

    return result.filePath;
});

registerIPCHandler(
    'FS_SHOW_INPUT_DIALOG',
    // @ts-ignore - async handler returns Promise
    async (title: string, defaultValue?: string) => {
        // Electron doesn't have a built-in input dialog, so we'll use a save dialog for now
        // A proper implementation would create a custom BrowserWindow with a form
        const result = await dialog.showSaveDialog({
            title,
            defaultPath: defaultValue || '',
            filters: [
                { name: 'JavaScript Files', extensions: ['js', 'mjs'] },
                { name: 'All Files', extensions: ['*'] },
            ],
        });

        if (result.canceled || !result.filePath) {
            return null;
        }

        // Return just the filename for rename operations
        return path.basename(result.filePath);
    },
);

registerIPCHandler('SHOW_UNSAVED_CHANGES_DIALOG', async (fileName: string) => {
    const result = await dialog.showMessageBox({
        type: 'warning',
        buttons: ['Save', "Don't Save", 'Cancel'],
        defaultId: 0, // Save is default (primary)
        cancelId: 2, // Cancel
        message: `Do you want to save the changes you made to ${fileName}?`,
        detail: "Your changes will be lost if you don't save them.",
    });

    return result.response; // Returns the button index: 0=Save, 1=Don't Save, 2=Cancel
});

let helpWindow: BrowserWindow | null = null;

const createHelpWindow = () => {
    if (helpWindow) {
        helpWindow.focus();
        return;
    }

    helpWindow = new BrowserWindow({
        width: 1500,
        height: 1000,
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
        title: 'Modular Help',
    });

    // Load the index.html of the app with #help hash
    helpWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY + '#help');

    helpWindow.on('closed', () => {
        helpWindow = null;
    });
};

registerIPCHandler('OPEN_HELP_WINDOW', async () => {
    createHelpWindow();
});

registerIPCHandler('OPEN_HELP_FOR_SYMBOL', async (symbolType: 'type' | 'module' | 'namespace', symbolName: string) => {
    createHelpWindow();
    // Send navigation message to help window after it loads
    if (helpWindow) {
        helpWindow.webContents.once('did-finish-load', () => {
            helpWindow?.webContents.send('navigate-to-symbol', { symbolType, symbolName });
        });
        // If already loaded, send immediately
        if (!helpWindow.webContents.isLoading()) {
            helpWindow.webContents.send('navigate-to-symbol', { symbolType, symbolName });
        }
    }
});

// Config IPC handlers
registerIPCHandler('CONFIG_GET_PATH', () => {
    ensureConfigExists();
    return CONFIG_FILE;
});

registerIPCHandler('CONFIG_READ', () => {
    ensureConfigExists();
    return loadConfig();
});

/**
 * Create the main application window
 */
const createWindow = (): void => {
    const isMac = process.platform === 'darwin';

    // Create the browser window.
    mainWindow = new BrowserWindow({
        height: 1000,
        width: 1500,
        titleBarStyle: isMac ? 'hiddenInset' : 'default',
        trafficLightPosition: isMac ? { x: 12, y: 10 } : undefined,
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
    });

    // Quit app when window is closed (on all platforms, including macOS)
    mainWindow.on('close', () => {
        app.quit();
    });

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Flush pending logs when the renderer is ready
    mainWindow.webContents.on('did-finish-load', () => {
        flushPendingLogs();
    });

    // Start watching config file for changes
    startConfigWatcher();
};

/**
 * Create the application menu
 */
const createMenu = (): void => {
    const isMac = process.platform === 'darwin';

    const template: Electron.MenuItemConstructorOptions[] = [
        // App menu (macOS only)
        ...(isMac
            ? [
                {
                    label: app.name,
                    submenu: [
                        { role: 'about' as const },
                        { type: 'separator' as const },
                        {
                            label: 'Settings...',
                            accelerator: 'Cmd+,',
                            click: () => {
                                if (mainWindow && !mainWindow.isDestroyed()) {
                                    mainWindow.webContents.send(
                                        MENU_CHANNELS.OPEN_SETTINGS,
                                    );
                                }
                            },
                        },
                        { type: 'separator' as const },
                        { role: 'services' as const },
                        { type: 'separator' as const },
                        { role: 'hide' as const },
                        { role: 'hideOthers' as const },
                        { role: 'unhide' as const },
                        { type: 'separator' as const },
                        { role: 'quit' as const },
                    ],
                },
            ]
            : []),
        // File menu
        {
            label: 'File',
            submenu: [
                {
                    label: 'Open Workspace...',
                    accelerator: 'CmdOrCtrl+O',
                    click: (_item, focusedWindow) => {
                        if (focusedWindow) {
                            BrowserWindow.fromId(
                                focusedWindow.id,
                            )?.webContents.send(MENU_CHANNELS.OPEN_WORKSPACE);
                        }
                    },
                },
                { type: 'separator' as const },
                {
                    label: 'Save',
                    accelerator: 'CmdOrCtrl+S',
                    click: (_item, focusedWindow) => {
                        if (focusedWindow) {
                            BrowserWindow.fromId(
                                focusedWindow.id,
                            )?.webContents.send(MENU_CHANNELS.SAVE);
                        }
                    },
                },
                {
                    label: 'Close Buffer',
                    accelerator: 'CmdOrCtrl+W',
                    click: (_item, focusedWindow) => {
                        if (focusedWindow) {
                            BrowserWindow.fromId(
                                focusedWindow.id,
                            )?.webContents.send(MENU_CHANNELS.CLOSE_BUFFER);
                        }
                    },
                },
                { type: 'separator' as const },
                isMac ? { role: 'close' as const } : { role: 'quit' as const },
            ],
        },
        // Edit menu
        {
            label: 'Edit',
            submenu: [
                { role: 'undo' as const },
                { role: 'redo' as const },
                { type: 'separator' as const },
                { role: 'cut' as const },
                { role: 'copy' as const },
                { role: 'paste' as const },
                ...(isMac
                    ? [
                        { role: 'pasteAndMatchStyle' as const },
                        { role: 'delete' as const },
                        { role: 'selectAll' as const },
                    ]
                    : [
                        { role: 'delete' as const },
                        { type: 'separator' as const },
                        { role: 'selectAll' as const },
                    ]),
            ],
        },
        // View menu
        {
            label: 'View',
            submenu: [
                { role: 'reload' as const },
                { role: 'forceReload' as const },
                {
                    label: 'Toggle Developer Tools',
                    accelerator: isMac ? 'Cmd+Option+I' : 'Ctrl+Shift+I',
                    click: (_item, focusedWindow) => {
                        if (focusedWindow) {
                            BrowserWindow.fromId(
                                focusedWindow.id,
                            )?.webContents.toggleDevTools();
                        }
                    },
                },
                { type: 'separator' as const },
                { role: 'resetZoom' as const },
                { role: 'zoomIn' as const },
                { role: 'zoomOut' as const },
                { type: 'separator' as const },
                { role: 'togglefullscreen' as const },
            ],
        },
        // Run menu
        {
            label: 'Run',
            submenu: [
                {
                    label: 'Update Patch',
                    accelerator: 'Ctrl+Enter',
                    click: (_item, focusedWindow) => {
                        if (focusedWindow) {
                            BrowserWindow.fromId(
                                focusedWindow.id,
                            )?.webContents.send(MENU_CHANNELS.UPDATE_PATCH);
                        }
                    },
                },
                {
                    label: 'Stop Sound',
                    accelerator: 'Ctrl+.',
                    click: (_item, focusedWindow) => {
                        if (focusedWindow) {
                            BrowserWindow.fromId(
                                focusedWindow.id,
                            )?.webContents.send(MENU_CHANNELS.STOP);
                        }
                    },
                },
                { type: 'separator' as const },
                {
                    label: 'Toggle Recording',
                    accelerator: 'Ctrl+R',
                    click: (_item, focusedWindow) => {
                        if (focusedWindow) {
                            BrowserWindow.fromId(
                                focusedWindow.id,
                            )?.webContents.send(MENU_CHANNELS.TOGGLE_RECORDING);
                        }
                    },
                },
                { type: 'separator' as const },
                {
                    label: 'Audio Settings...',
                    accelerator: isMac ? undefined : 'CmdOrCtrl+,',
                    click: (_item, focusedWindow) => {
                        if (focusedWindow) {
                            BrowserWindow.fromId(
                                focusedWindow.id,
                            )?.webContents.send(MENU_CHANNELS.OPEN_SETTINGS);
                        }
                    },
                },
            ],
        },
        // Window menu
        {
            label: 'Window',
            submenu: [
                { role: 'minimize' as const },
                { role: 'zoom' as const },
                ...(isMac
                    ? [
                        { type: 'separator' as const },
                        { role: 'front' as const },
                        { type: 'separator' as const },
                        { role: 'window' as const },
                    ]
                    : [{ role: 'close' as const }]),
            ],
        },
    ];

    const menu = Menu.buildFromTemplate(template);
    Menu.setApplicationMenu(menu);
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
    // Load last opened folder
    const config = loadConfig();
    if (config.lastOpenedFolder && fs.existsSync(config.lastOpenedFolder)) {
        currentWorkspaceRoot = config.lastOpenedFolder;
        console.log('Restored last opened folder:', currentWorkspaceRoot);
    }

    // Audio configuration is already restored during Synthesizer initialization
    // (the config is passed to the constructor)

    createWindow();
    createMenu();
});

// Quit when all windows are closed (on all platforms, including macOS)
app.on('window-all-closed', () => {
    app.quit();
});

// Remove the macOS-specific reactivation behavior since we want single window only
app.on('activate', () => {
    // Prevent window recreation on macOS
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
