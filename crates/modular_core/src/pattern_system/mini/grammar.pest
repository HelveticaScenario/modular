// Mini notation grammar for Strudel-style patterns
// Supports: sequences, stacks, subsequences, modifiers, operators, and tails

// Entry point: a pattern expression optionally followed by operator chain
program = { SOI ~ pattern_expr ~ operator_chain? ~ EOI }

// Operator chain: $ operator(arg) $ operator(arg) ...
operator_chain = { operator_call+ }
operator_call = { "$" ~ WHITESPACE* ~ identifier ~ variant? ~ "(" ~ WHITESPACE* ~ pattern_expr? ~ WHITESPACE* ~ ")" }
variant = { "." ~ identifier }

// Pattern expressions - stack is lowest precedence
pattern_expr = { stack_expr }

// Stack: comma-separated patterns (simultaneous)
stack_expr = { sequence_expr ~ (WHITESPACE* ~ "," ~ WHITESPACE* ~ sequence_expr)* }

// Sequence: space-separated elements with optional weights
sequence_expr = { weighted_elem+ }

// Weighted element: element with optional weight (@n)
weighted_elem = { element ~ (WHITESPACE* ~ "@" ~ WHITESPACE* ~ number)? ~ WHITESPACE* }

// Element types - with optional tail for list syntax like [a b]:minor
element = { element_base ~ (":" ~ tail_element)* }
element_base = {
    polymeter |
    fast_sub |
    slow_sub |
    group |
    modified_atom
}

// Grouping
group = { "(" ~ WHITESPACE* ~ pattern_expr ~ WHITESPACE* ~ ")" }

// Subsequences
fast_sub = { "[" ~ WHITESPACE* ~ pattern_expr ~ WHITESPACE* ~ "]" }
slow_sub = { "<" ~ WHITESPACE* ~ pattern_expr ~ WHITESPACE* ~ ">" }

// Polymeter: {a b, c d e}
polymeter = { "{" ~ WHITESPACE* ~ sequence_expr ~ (WHITESPACE* ~ "," ~ WHITESPACE* ~ sequence_expr)+ ~ WHITESPACE* ~ "}" }

// Atom with modifiers
modified_atom = { atom ~ modifier* }

// Modifiers (applied to atoms)
modifier = {
    fast_mod |
    slow_mod |
    replicate |
    degrade |
    euclidean
}

fast_mod = { "*" ~ slice }
slow_mod = { "/" ~ slice }
replicate = { "!" ~ integer? }
degrade = { "?" ~ number? }
euclidean = { "(" ~ WHITESPACE* ~ integer ~ WHITESPACE* ~ "," ~ WHITESPACE* ~ integer ~ (WHITESPACE* ~ "," ~ WHITESPACE* ~ integer)? ~ WHITESPACE* ~ ")" }

// A slice can be a number or a subsequence
slice = { number | fast_sub | slow_sub | group }

// Atoms - the basic building blocks
atom = {
    rest |
    range_pattern |
    random_choice |
    value
}

// Rest/silence
rest = { "~" | "-" }

// Range: 0..4 becomes [0, 1, 2, 3, 4]
range_pattern = { integer ~ ".." ~ integer }

// Random choice: a | b | c
random_choice = { value ~ (WHITESPACE* ~ "|" ~ WHITESPACE* ~ value)+ }

// Tail element for list syntax: allows values or subpatterns after :
tail_element = { fast_sub | slow_sub | group | value }

// Values - various atom types
value = {
    hz_value |
    volts_value |
    midi_value |
    note_value |
    number |
    string |
    identifier
}

// Number formats
hz_value = { number ~ "hz" }
volts_value = { number ~ "v" }
midi_value = { "m" ~ integer }
// note_value must be atomic (@) to prevent implicit whitespace consumption
// This ensures "a b" is parsed as two notes, not "a" with flat "b"
note_value = @{ note_letter ~ accidental? ~ octave? }

// Note components
note_letter = { 'a'..'g' | 'A'..'G' }
// Single accidental only: # or s for sharp, b for flat
accidental = { "#" | "s" | "b" }
octave = { "-"? ~ ASCII_DIGIT+ }

// Basic types
number = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
integer = @{ "-"? ~ ASCII_DIGIT+ }
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
string = { "\"" ~ inner_string ~ "\"" }
inner_string = @{ (!"\"" ~ ANY)* }

// Whitespace handling
WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
