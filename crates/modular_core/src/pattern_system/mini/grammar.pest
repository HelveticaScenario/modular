// Mini notation grammar for Strudel-style patterns
// Simplified: sequences, subsequences, modifiers, random choice
// Removed: stacks, polymeter, $ operator() syntax, range, "-" rest

// Entry point: a pattern expression
program = { SOI ~ pattern_expr ~ EOI }

// Pattern expressions - sequence of elements
pattern_expr = { sequence_expr }

// Sequence: space-separated elements
// Weight (@) is now part of modifiers, so all operators can be mixed in any order
sequence_expr = { element+ }

// Element types - with optional tail for list syntax like [a b]:minor
// All modifiers (including weight @) can be applied in any order
element = { element_base ~ modifier* ~ (":" ~ tail_element)* ~ WHITESPACE* }
element_base = {
    fast_sub |
    slow_sub |
    group |
    atom
}

// Grouping
group = { "(" ~ WHITESPACE* ~ pattern_expr ~ WHITESPACE* ~ ")" }

// Subsequences
fast_sub = { "[" ~ WHITESPACE* ~ pattern_expr ~ WHITESPACE* ~ "]" }
slow_sub = { "<" ~ WHITESPACE* ~ pattern_expr ~ WHITESPACE* ~ ">" }

// Modifiers (applied to atoms) - weight is now a modifier like in Strudel
modifier = {
    weight |
    fast_mod |
    slow_mod |
    replicate |
    degrade |
    euclidean
}

// Modifier operands can be numbers, fast subsequences, or slow subsequences
mod_operand = { number | fast_sub | slow_sub | group }

// Weight modifier (@n) - like Strudel's op_weight
weight = { "@" ~ number? }
fast_mod = { "*" ~ mod_operand }
slow_mod = { "/" ~ mod_operand }
replicate = { "!" ~ integer? }
degrade = { "?" ~ number? }
euclidean = { "(" ~ WHITESPACE* ~ mod_operand ~ WHITESPACE* ~ "," ~ WHITESPACE* ~ mod_operand ~ (WHITESPACE* ~ "," ~ WHITESPACE* ~ mod_operand)? ~ WHITESPACE* ~ ")" }

// Atoms - the basic building blocks
atom = {
    random_choice |
    rest |
    value
}

// Rest/silence - only tilde
rest = { "~" }

// Choice element: used in random_choice, can be value or rest
choice_element = { rest | value }

// Random choice: a | b | c (can include rests like c|~)
random_choice = { choice_element ~ (WHITESPACE* ~ "|" ~ WHITESPACE* ~ choice_element)+ }

// Tail element for list syntax: allows values or subpatterns after :
tail_element = { fast_sub | slow_sub | group | value }

// Values - various atom types
value = {
    module_ref |
    hz_value |
    volts_value |
    midi_value |
    note_value |
    number |
    string |
    identifier
}

// Module reference: module(id:port) or module(id:port)= for sample-and-hold
// The inner content allows alphanumeric, underscore, hyphen, and colon
module_ref = @{ "module(" ~ module_ref_inner ~ ")" ~ "="? }
module_ref_inner = @{ (ASCII_ALPHANUMERIC | "_" | "-" | ":")+ }

// Number formats
hz_value = { number ~ "hz" }
volts_value = { number ~ "v" }
midi_value = { "m" ~ integer }
// note_value must be atomic (@) to prevent implicit whitespace consumption
// This ensures "a b" is parsed as two notes, not "a" with flat "b"
note_value = @{ note_letter ~ accidental? ~ octave? }

// Note components
note_letter = { 'a'..'g' | 'A'..'G' }
// Single accidental only: # or s for sharp, b for flat
accidental = { "#" | "s" | "b" }
octave = { "-"? ~ ASCII_DIGIT+ }

// Basic types
number = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
integer = @{ "-"? ~ ASCII_DIGIT+ }
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
string = { "\"" ~ inner_string ~ "\"" }
inner_string = @{ (!"\"" ~ ANY)* }

// Whitespace handling
WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
